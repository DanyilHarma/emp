# Проект: МойСклад (B2B, SaaS, eCommerce / ERP)

[https://online.moysklad.ru](https://online.moysklad.ru)

---

## Описание проекта (что это такое?)

**МойСклад** — это онлайн-сервис для учёта товаров, заказов, финансов и клиентов.  
Платформа автоматизирует процессы для малого и среднего бизнеса в сферах розницы, опта, производства и онлайн-торговли.

Ключевой фокус — управление остатками, синхронизация с кассами, маркетплейсами и CRM.

---

## Кто и как им пользуется?

-   **Бухгалтера / Менеджеры:** ведут заказы, отгрузки, остатки, контролируют финансы.
-   **Владельцы бизнеса:** следят за показателями, работают с аналитикой, подключают интеграции.
-   **Кладовщики:** ведут склад, маркируют, собирают заказы.
-   **Клиенты:** оформляют заказы через внешние каналы (синхронизация с сайтами, маркетплейсами).

---

## Что мне сразу бросилось в глаза

-   Интерфейс сложный, многофункциональный, ориентирован на постоянную работу.
-   Используется **React** — подтверждено через `Wappalyzer`.
-   Очень **мало ресурсов во вкладке Network** — JS-бандлы не видны. Они загружаются и кешируются через Service Worker, вероятно, лениво.
-   Активно используются **Service Workers** (firebase-messaging), которые кешируют статику и управляют пушами.
-   Приложение использует **IndexedDB**, **Session Storage** и **Local Storage**. В IndexedDB — `fpid`, `rb_sync`, токены, флаги синхронизации.
-   Внутри DevTools видно обилие нестандартных классов (`-4vKk`, `+WeQT`) — возможно, генерация через CSS Modules или Emotion.
-   Есть атрибуты `data-react-root`, что подтверждает использование React.
-   Реализованы пуш-уведомления через **Firebase Cloud Messaging** — с кастомной логикой обработки событий, включая `postMessage` в открытые вкладки.
-   Присутствует доступ к `chrome.runtime` API — может использоваться для взаимодействия с расширением (подключение `chrome.runtime.onMessage`), которое расширяет функциональность ЛК.

---

## Как устроена загрузка и инициализация?

-   В Network **отсутствуют видимые js-файлы**, даже с выключенным кэшем.
-   Приложение загружается через **Service Worker**, что позволяет скрыть основную загрузку и выдавать ресурсы из кеша.
-   Видны ссылки вида `/app/cdn/r1488-1/js/firebase-app.js`, что указывает на кастомный CDN и строгую систему версионирования (`r1488-1`).
-   Подключены чанки по ключу `data-mf`, что говорит о модульной загрузке фичей (feature-split).
-   Используется code-splitting, видно по чанкам вроде `purposeEditor.chunk.js`, `welcomeWindowMobile.chunk.js` и т.д.

---

## Что можно найти в IndexedDB?

-   БД `fcm_token_details_db`, `firebase-messaging`, `fpid`, `rb_sync`.
-   Хранятся данные вроде:
    -   `fpid`, `pausedSites`, `lastSentTime`, `hash`.
-   Эти данные могут использоваться для:
    -   идентификации устройства и аналитики (fpid),
    -   трекинга событий или оффлайн-данных (rb_sync),
    -   вспомогательной логики клиент-серверной синхронизации.
-   Срок жизни данных не явно ограничен, но они остаются между сессиями. Логика их обновления, вероятно, завязана на события `push` или ручные `sync`.

---

## Интеграции

-   Firebase: пуши, возможно авторизация (в `firebaseAppConfig` задано `authDomain`).
-   Используется `firebase-messaging-sw.js` — кастомный SW, который управляет пушами, фокусом окна и передачей данных.
-   Присутствуют трекеры (`gtag`, `mc.yandex.ru`, zopim), но в рамках архитектуры ядра они роли не играют.
-   Используется `fingerprint2.min.js`, что говорит о генерации уникального ID устройства.

---

## Структура продукта по блокам

-   Управление товарами и складом
-   Документы: заказы, отгрузки, возвраты, счета
-   Финансовый модуль
-   Интеграции с кассами, маркетплейсами и CRM
-   Отчётность и дашборды
-   Поддержка нескольких организаций
-   Управление пользователями и правами

---

## Примерный стек

-   **Frontend:** React (по признакам в DOM и `data-react-root`), сборка через Webpack с чётким CDN-распределением
-   **State:** возможно Redux, но не видно глобальных стораджей — может быть кастомный менеджмент
-   **CSS:** генерация через CSS Modules или Emotion
-   **API:** REST, передача данных в JSON, пуши через Firebase
-   **Storage:** IndexedDB (fpid, rb_sync), LocalStorage, SessionStorage
-   **Push:** Firebase Cloud Messaging, с кастомным SW
-   **Сервис-воркеры:** активны, управляют кешем и пушами
-   **Auth:** авторизация через Firebase или собственную прослойку, в коде используется `firebaseApp.initializeApp(...)`
-   **Chrome API:** используется, вероятно, в связке с расширением или как средство обмена сообщениями между вкладками

---

## Где могла бы быть боль у фронта

-   **Глубокая интеграция с Firebase и IndexedDB** — сложно дебажить, сложно воспроизвести поведение в оффлайне.
-   **Service Worker** скрывает реальные запросы и может кэшировать устаревшие данные — важно контролировать lifecycle SW.
-   **Модули со своим чанками** требуют строгой синхронизации с роутингом и версионированием.
-   **Состояние может жить в нескольких слоях** — в памяти, IndexedDB, в Firebase, что требует синхронизации и конфликт-менеджмента.
-   **Отслеживание состояния фокуса и клика** на пушах — нестандартная логика, которая может ломаться.
-   **Профайлинг и device fingerprinting** добавляют технический долг, связанный с соблюдением GDPR / безопасности.

---

## Интересные детали, которые хочется пощупать

-   Как устроен механизм `rb_sync` — похож на очередь синхронизации или отложенные действия при оффлайне.
-   Что именно делает `fpid` — по виду это fingerprint ID, возможно, для трекинга или сегментации.
-   Логика регистрации пушей: пуш приходит, SW передаёт данные в клиент через `postMessage`, а не просто показывает уведомление.
-   Внутри Service Worker есть кастомные фильтры (`UNREAD_NEWS_AVAILABLE`), что говорит о системах на основе триггеров.
-   Есть ощущение, что у некоторых модулей может быть rollback — например, если пуш не удался, он просто игнорируется (handler возвращает пустой промис).

---

## Что стоит пощупать руками

### Создание документа (заказ, отгрузка)

-   Как устроена форма
-   Как валидируются поля
-   Какой UX при ошибке или сохранении
-   Есть ли optimistic UI

### Переключение между организациями

-   Перезагружается ли приложение
-   Сбрасывается ли стейт
-   Как обрабатываются данные между сессиями

### Работа с таблицами и отчетами

-   Есть ли windowing или lazy-load
-   Как реализована фильтрация, сортировка, поиск

### Настройка прав доступа

-   Как устроено распределение прав по пользователям и организациям

### Пуш-уведомления

-   Как приходят
-   Можно ли вызвать вручную событие
-   Что отображается при клике

### Интеграции (кассы, CRM, маркетплейсы)

-   Как выглядят настройки
-   Есть ли очереди или статус отправки
-   Можно ли отследить лог ошибок

### Offline/online поведение

-   Как ведёт себя интерфейс при потере соединения
-   Есть ли fallback или алерт

### Механика авторизации и logout

-   Как реализована персистентность
-   Когда истекает токен
-   Что происходит при выходе

---
